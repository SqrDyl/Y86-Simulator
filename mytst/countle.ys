        .pos 0
#initialize %rax to 0
irmovq $0, %rax
#initialize another register to the address of the first number
irmovq nums, %r8
#it can also be helpful to initialize another register to 1
irmovq $1, %r9
nop
nop
#for each number:  
#get the number out of memory
mrmovq (%r8), %r10
nop
nop
nop
#cause the condition codes to be modified based upon value of the number
#add 1 to %rax if number <= 0; otherwise, add 0 to %rax
cmovle %r10, %r11
addq %r9, %rax

mrmovq 1(%r8), %r10
nop
nop
nop
cmovle %r9, %rax


mrmovq 2(%r8), %r10
nop
nop
nop
cmovle %r9, %rax


mrmovq 3(%r8), %r10
nop
nop
nop
cmovle %r9, %rax

mrmovq 4(%r8), %r10
nop
nop
nop
cmovle %r9, %rax



#finally store %rax in memory location result
rmmovq %rax, result


        halt
        .align 8
result: .quad 0     #should be 3 at end
nums:   .quad 11
        .quad -23
        .quad 0
        .quad 15
        .quad -3
        .quad 4

